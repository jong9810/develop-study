엔티티 매니저는 쓰레드 간에 공유하면 절대 안된다.
JPA의 모든 데이터 변경은 트랜잭션 내에서 실행해야 한다(수정, 삭제, 삽입).

JPQL : SQL을 추상화한 객체 지향 쿼리 언어.
엔티티 객체를 대상으로 쿼리를 작성한다.
db 방언에 맞춰서 JPA가 번역을 해준다.
SQL 문법과 유사하다(select, from, where, group by, having, join 지원).

<영속성 컨텍스트 상태 종류>
1) 비영속 상태 : JPA와는 상관없는 상태(엔티티 객체 생성)
2) 영속 상태 : 영속성 컨텍스트(1차 캐시)가 객체를 관리하는 상태(em.persist())
3) 준영속 상태 : 영속성 컨텍스트에서 분리된 상태(em.detach())
4) 삭제 : 객체를 삭제한 상태(em.remove())
* 트랜잭션이 커밋될 때 db에 쿼리를 날린다.

<영속성 컨텍스트의 이점>
1) 1차 캐시(영속성 컨텍스트)
2) 동일성(identity) 보장( == )
3) 트랜잭션을 지원하는 쓰기 지연(transactional write-behind)
4) 변경 감지(Dirty Checking)
5) 지연 로딩(Lazy Loading)

<1차 캐시>
* 1차 캐시의 key 값은 @Id 어노테이션을 붙인 멤버변수이고, value 값은 엔티티 객체가 된다.
* 조회할 때 먼저 1차 캐시에 있는지 확인하고 있으면 1차 캐시값으로 반환하고, 없으면 DB에서 조회한 후 1차 캐시에 저장하고 반환해준다.
* 1차 캐시는 트랜잭션 단위에서만 존재하기 때문에 그렇게 큰 성능의 이점이 있지는 않다.

<영속 엔티티의 동일성 보장>
* 같은 트랜잭션 내에서 똑같은 식별자를 갖는 인스턴스에 대해 같은 주소를 참조한다.
* 1차 캐시로 반복 가능한 읽기(Repeatable Read) 등급의 트랜잭션 격리 수준을 db가 아닌 애플리케이션 차원에서 제공한다.

<트랜잭션을 지원하는 쓰기 지연>
* 커밋하는 순간 한꺼번에 DB에 insert 쿼리를 보낸다.
* em.persist(memberA)를 하면 memberA가 1차 캐시에 들어가고, JPA가 엔티티를 분석해서 insert 쿼리를 쓰기 지연 SQL 저장소에 저장한다.
* 마찬가지로 em.persist(memberB)도 위와 같은 과정이 일어나고 tx.commit()을 하면 쓰기 지연 SQL 저장소의 SQL이 DB로 보내진다(em.flush()).
* 버퍼링 가능(모았다가 한 번에 db로 보냄, 성능 향상 여지가 있음)

<엔티티 수정 - 변경 감지>
* 트랜잭션 commit을 하면 em.flush()가 호출된다.
* 1차 캐시에는 스냅샷과 엔티티가 저장되는데, 스냅샷에는 값을 읽어온 시점의 데이터가 저장되어 있고, 엔티티는 최종적으로 변경된 엔티티의 데이터가 들어있다.
* flush() 함수는 스냅샷과 엔티티를 비교하여 달라진 부분의 update 쿼리들을 생성하여 쓰기 지연 SQL 저장소에 저장한다.
* 그 다음 update 쿼리를 db에 반영하고 commit을 한다.
* 참고: em.remove() 함수도 비슷하게 동작하지만 update 쿼리가 delete 쿼리로 바뀐다는 점만 다르다.

플러시(flush) : 영속성 컨텍스트의 변경 내용을 db에 반영하는 것.










