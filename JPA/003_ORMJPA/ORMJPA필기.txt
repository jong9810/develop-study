엔티티 매니저는 쓰레드 간에 공유하면 절대 안된다.
JPA의 모든 데이터 변경은 트랜잭션 내에서 실행해야 한다(수정, 삭제, 삽입).

JPQL : SQL을 추상화한 객체 지향 쿼리 언어.
엔티티 객체를 대상으로 쿼리를 작성한다.
db 방언에 맞춰서 JPA가 번역을 해준다.
SQL 문법과 유사하다(select, from, where, group by, having, join 지원).

<영속성 컨텍스트 상태 종류>
1) 비영속 상태 : JPA와는 상관없는 상태(엔티티 객체 생성)
2) 영속 상태 : 영속성 컨텍스트(1차 캐시)가 객체를 관리하는 상태(em.persist())
3) 준영속 상태 : 영속성 컨텍스트에서 분리된 상태(em.detach())
4) 삭제 : 객체를 삭제한 상태(em.remove())
* 트랜잭션이 커밋될 때 db에 쿼리를 날린다.

<영속성 컨텍스트의 이점>
1) 1차 캐시(영속성 컨텍스트)
2) 동일성(identity) 보장( == )
3) 트랜잭션을 지원하는 쓰기 지연(transactional write-behind)
4) 변경 감지(Dirty Checking)
5) 지연 로딩(Lazy Loading)

<1차 캐시>
* 1차 캐시의 key 값은 @Id 어노테이션을 붙인 멤버변수이고, value 값은 엔티티 객체가 된다.
* 조회할 때 먼저 1차 캐시에 있는지 확인하고 있으면 1차 캐시값으로 반환하고, 없으면 DB에서 조회한 후 1차 캐시에 저장하고 반환해준다.
* 1차 캐시는 트랜잭션 단위에서만 존재하기 때문에 그렇게 큰 성능의 이점이 있지는 않다.

<영속 엔티티의 동일성 보장>
* 같은 트랜잭션 내에서 똑같은 식별자를 갖는 인스턴스에 대해 같은 주소를 참조한다.
* 1차 캐시로 반복 가능한 읽기(Repeatable Read) 등급의 트랜잭션 격리 수준을 db가 아닌 애플리케이션 차원에서 제공한다.

<트랜잭션을 지원하는 쓰기 지연>
* 커밋하는 순간 한꺼번에 DB에 insert 쿼리를 보낸다.
* em.persist(memberA)를 하면 memberA가 1차 캐시에 들어가고, JPA가 엔티티를 분석해서 insert 쿼리를 쓰기 지연 SQL 저장소에 저장한다.
* 마찬가지로 em.persist(memberB)도 위와 같은 과정이 일어나고 tx.commit()을 하면 쓰기 지연 SQL 저장소의 SQL이 DB로 보내진다(em.flush()).
* 버퍼링 가능(모았다가 한 번에 db로 보냄, 성능 향상 여지가 있음)

<엔티티 수정 - 변경 감지>
* 트랜잭션 commit을 하면 em.flush()가 호출된다.
* 1차 캐시에는 스냅샷과 엔티티가 저장되는데, 스냅샷에는 값을 읽어온 시점의 데이터가 저장되어 있고, 엔티티는 최종적으로 변경된 엔티티의 데이터가 들어있다.
* flush() 함수는 스냅샷과 엔티티를 비교하여 달라진 부분의 update 쿼리들을 생성하여 쓰기 지연 SQL 저장소에 저장한다.
* 그 다음 update 쿼리를 db에 반영하고 commit을 한다.
* 참고: em.remove() 함수도 비슷하게 동작하지만 update 쿼리가 delete 쿼리로 바뀐다는 점만 다르다.

<플러시(flush)>
* 영속성 컨텍스트의 변경 내용을 db에 반영하는 것(영속성 컨텍스트와 db를 동기화).
* 플러시를 해도 1차 캐시는 모두 유지가 되고, 쓰기 지연 SQL 저장소에 있는 SQL만 db에 반영한다.
* 커밋 직전에만 동기화하면 된다(트랜잭션이라는 작업단위가 중요!).
* 사용법
1) em.flush() : 직접 호출.
2) 트랜잭션 커밋 전 : 플러시 자동 호출.
3) JPQL 쿼리 실행 전 : 플러시 자동 호출.
* 플러시 모드 옵션(쓸 일은 잘 없음) : em.setFlushMode(FlushModeType.COMMIT)
1) FlushModeType.AUTO : 커밋이나 쿼리를 실행할 때 플러시(기본값)
2) FlushModeType.COMMIT : 커밋할 때만 플러시

<준영속 상태>
* 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached)된 상태.
* 영속성 컨텍스트가 제공하는 기능을 사용할 수 없다(변경 감지, 지연 로딩 등).
* 준영속 상태 만드는 방법
1) em.detach(entity) : 특정 엔티티만 준영속 상태로 전환.
2) em.clear() : 영속성 컨텍스트를 완전히 초기화.
3) em.close() : 영속성 컨텍스트를 종료.

<db 스키마 자동 생성>
* ddl을 애플리케이션 실행 시점에 자동 생성.
* db 방언을 활용해서 db에 적절한 ddl을 생성.
* 생성된 ddl은 꼭 개발 단계에서만 사용해야 함.
* 생성된 ddl은 운영서버에서는 사용하지 않거나 적절히 다듬은 후 사용해야 함.
* hibername.hbm2ddl.auto(maven)을 persistence.xml 파일에 등록해서 사용.
* 옵션
1) create : 기존 테이블 삭제 후 다시 생성(drop + create)
2) create-drop : create와 같으나 종료시점에 테이블 drop(drop + create + drop, 테스트 케이스인 경우)
3) update : 변경분만 반영(운영 db에서는 사용하면 안됨, 컬럼 삭제는 안됨)
4) validate : 엔티티와 테이블이 정상 매핑되었는지만 확인.
5) none : 사용하지 않음.
* 주의점
1) 운영 장비에는 절대 create, create-drop, update를 사용하면 안된다!
2) 개발 초기 단계는 create 또는 update
3) 테스트 서버는 update 또는 validate
4) 스테이징과 운영 서버는 validate 또는 none
5) 개발 서버나 테스트 서버에서도 가급적이면 create, create-drop, update는 사용을 지양하자(JPA가 생성하는 sql은 위험할 수 있음).

<ddl 생성 기능>
* 런타임에 영향을 주지 않는 ddl을 자동으로 생성해주는 기능.
* ddl 생성 기능은 ddl을 자동 생성할 때만 사용되고 JPA의 로직에는 영향을 주지 않는다.
* ex) 제약조건 추가(unique, not null, length 등)

<객체와 테이블 매핑>
1. @Entity
* JPA가 관리 하는 클래스 위에 붙인다.
* JPA를 사용해서 테이블과 매핑할 클래스에 필수.
* 주의!
1) 기본 생성자 필수(파라미터가 없는 public 또는 protected 생성자)
2) final 클래스, enum, interface, inner 클래스에는 사용 못함
3) 저장할 필드에 final 사용하면 안됨
* 속성
1) name : JPA에서 사용할 엔티티 이름을 지정한다(기본값 : 클래스 이름, 같은 이름을 클래스가 없으면 기본값을 사용하자).

2. @Table
* 속성
1) name : 엔티티와 매핑할 테이블을 지정한다.
2) uniqueConstraints : unique 제약조건(이름, 컬럼 등)을 직접 작성할 수 있다.

<필드와 컬럼 매핑>
1. @Column
* 속성
1) name : 필드와 매핑할 db 컬럼명을 지정.
2) insertable, updateable : 등록, 변경 가능 여부 지정(기본값은 true).
3) nullable : null 값의 허용 여부 지정(false는 not null, true(기본값)은 null).
4) unique : 유니크 제약 조건 여부 지정(true는 unique, false는 unique X). 이름이 랜덤하게 생성돼서 잘 안 쓰임.
5) columnDefinition : db 컬럼 정보를 직접 줄 수 있다. ex) varchar(100) default 'EMPTY'
6) length : 문자 길이 제약조건, String 타입에만 사용한다.
7) precision, scale
* BigDecimal이나 BigInteger 타입에 사용한다.
* precision은 소수점을 포함한 전체 자릿수를 지정한다.
* scale은 소수의 자릿수를 지정한다.
* 참고로 double, float 타입에는 적용되지 않는다(정밀한 소수를 다루어야할 때만 사용).

2. @Enumerated(EnumType.STRING)
* Enum 타입을 사용할 컬럼 위에 선언한다.
* Enum 타입은 STRING이나 ORDINAL(기본값)이 있는데 STRING을 사용하는 게 에러를 줄일 수 있다.

3. @Temporal(TemporalType.TIMESTAMP)
* 날짜 타입을 쓸 컬럼 위에 선언한다.
* LocalDate, LocalDateTime을 사용하면 생략할 수 있다.
* Temporal 타입
1) DATE : 날짜
2) TIME : 시간
3) TIMESTAMP : 날짜 + 시간

4. @Lob
* varchar 타입을 넘어서는 크기가 큰 컨텐츠(blob, clob)를 넣을 경우 사용한다.
* 속성을 지정할 게 없다.
* 매핑할 타입이 문자이면 clob(String, char[], java.sql.CLOB), 나머지는 blob(byte[], java.sql.BLOB)으로 매핑된다.

5. @Transient
* 테이블에 매핑을 하지 않고 메모리에서만 사용할 멤버변수 위에 선언한다.

<기본키 매핑>
1. @Id : 직접 할당
2. @GeneratedValue : 자동 할당
* 속성
1) strategy : 기본키 자동 생성 전략을 선택한다.
GenerationType.IDENTITY : 기본키 생성을 데이터베이스에 위임(MySql의 Auto_Increment).
GenerationType.SEQUENCE : 시쿼스 오브젝트를 통해 값을 가져오고 세팅해줌(Oracle에서 주로 사용됨, @SequenceGenerator로 설정할 수 있음).
GenerationType.TABLE : 키 생성 전용 테이블을 하나 만들어서 db 시퀀스를 흉내내는 전략(모든 db에 적용 가능, 성능이 낮음, @TableGenerator로 설정할 수 있음). 
* 권장하는 식별자 전략
자연키 : 주민등록번호, 전화번호 등
대리키(대체키) : 자동 생성 키, 랜덤 값 등
기본키는 null이면 안되고, 유일하고, 변하면 안된다.
이 조건을 만족하는 자연키는 찾기 어렵기 때문에 대리키를 사용하는 것을 권장한다.
ex) Long형 + 대체키 + 키 생성 전략 사용
* IDENTITY 전략
1) db에 값을 넣어봐야 기본키 값을 알 수 있기 때문에 이 전략만 예외적으로 em.persist()하면 insert 쿼리를 db에 날린다.
2) 그리고나서 jpa가 내부적으로 insert한 데이터를 가져온다(영속 상태).
3) 그렇기 때문에 IDENTITY 전략에서는 데이터를 모아서 한 번에 insert하는 것이 불가능하다(버퍼링해서 insert 하는 게 큰 메리트는 아님, 작은 단점).
참고 : 트랜잭션을 여러 번 잘라서 하는 건 성능에 문제가 될 수 있지만 한 트랜잭션 안에서 여러 번 쿼리를 날리는 것은 크게 문제가 되진 않는다.
* SEQUENCE 전략
1) em.persist()하면 시퀀스에서 pk값을 가져오고 tx.commit()할 때 insert 쿼리를 날린다(영속 상태로 만들기 위해서는 pk값이 필요하기 때문).
2) @SequenceGenerator 속성 중 initialValue, allocationSize를 사용하면 db에 allocationSize만큼 시퀀스를 미리 생성해놓고 생성된 시퀀스를 다 쓰기 전까지는 메모리에서 시퀀스를 사용(db 시퀀스 쿼리x)하게 된다.
* TABLE 전략
테이블 전략도 SEQUENCE 전략과 마찬가지로 @TableGenerator 속성 중 initialValue, allocationSize를 사용하여 최적화할 수 있다(동시성 문제 없음).

<연관관계 기초>
객체를 테이블에 맞추어 데이터 중심으로 모델링하면 협력관계를 만들 수 없다.
* 테이블은 외래키로 조인해서 연관된 테이블을 찾는다.
* 객체는 참조를 사용해서 연관된 객체를 찾는다.
* 테이블과 객체 사이의 이런 큰 간극이 있다.

<단방향 연관관계>
* 연관관계를 매핑할 때는 현재 클래스의 기준에서 @ManyToOne, @ManyToMany, @OneToOne, @OneToMany를 사용한다.
* @JoinColumn(name = "[조인할 테이블 컬럼]") : 어떤 컬럼으로 조인할 것인지 지정한다.

<양방향 연관관계>
참고 : 관례로 컬렉션 멤버 변수는 초기화를 함(NullPointException 방지).
* 양방향 연관관계 : 연관관계인 Entity 양쪽에 모두 레퍼런스를 넣어두고 서로 참조를 할 수 있는 관계.
* 테이블의 연관관계는 외래키 하나로 양방향 연관관계가 가능하다(방향의 개념 자체가 없음).
* 객체의 연관관계는 객체의 레퍼런스가 있어야지 참조할 수 있다(방향성이 있음).
* 양방향 연관관계는 가급적이면 사용하지 않는 것이 좋다(신경써야할 것들이 많아짐).
ex) @OneToMany(mappedBy = "team") : 반대편 Entity의 멤버변수 team과 연결되어 있다는 의미.
* mappedBy를 왜 사용하는지 근본적인 이유를 알지 못하면 언제 사용해야 하는지 감이 오지 않는다.
* 객체와 테이블이 관계를 맺는 차이를 이해하면 mappedBy를 사용하는 이유에 대해 알 수 있다.
1) 객체의 연관관계(단방향 2개)
회원 -> 팀 연관관계(단방향)
팀 -> 회원 연관관계(단방향)
2) 테이블의 연관관계(양방향 1개)
회원 <-> 팀의 연관관계(양방향, 엄밀히 말하면 방향이 없음(외래키 하나만 있으면 됨))
* 객체의 양방향 관계는 사실 양방향 관계가 아니라 서로 다른 단방향 관계 2개이다(단방향 연관관계 2개를 만들어야 함).
* 테이블은 외래키 하나로 두 테이블의 연관관계를 관리한다(양쪽으로 조인할 수 있음).
* JPA가 테이블을 매핑할 때 양방향 연관관계는 외래키를 어떤 것으로 매핑해야 할지 헷갈리게 된다.
* 그렇기 때문에 양방향 연관관계에서는 둘 중 하나로 외래키를 관리해야 한다(연관관계 주인).

<연관관계의 주인>
* 진짜 매핑 : 연관관계의 주인, 가짜 매핑 : 주인의 반대편(mappedBy)
* 양방향 연관관계에서 객체의 두 관계 중 하나를 연관관계의 주인으로 지정한다.
* 연관관계의 주인만이 외래키를 관리(등록, 수정)한다.
* 주인이 아닌 쪽은 읽기만 가능하다!!
* 주인은 mappedBy 속성을 사용하지 않고, 주인이 아닌 객체에 mappedBy 속성으로 주인을 지정해준다.
* 테이블 입장에서 보면 무조건 외래키가 있는 곳이 다이고, 외래키가 없는 곳이 일이다.
* 연관관계의 주인은 외래키가 있는 곳으로 하면 된다(다대일 관계라면 다쪽).
* 만약 외래키가 없는 곳으로 연관관계 주인을 지정하면 sql이 외래키가 있는 테이블로 나가기 때문에 헷갈릴 수 있다(직관적이지 않음).
* 외래키가 없는 연관관계 주인은 성능 이슈도 있다(나중에 자세히, 쿼리가 여러 번 나갈 수 있음).
* 연관관계의 주인은 비즈니스적으로 중요한 객체가 아니라 연관관계에서 다쪽이다.
* 그렇게 해야 설계도 깔끔하고 성능 이슈도 없다.

<양방향 매핑시 주의점>
* 양방향 연관관계 매핑시 연관관계의 주인에 값을 입력하지 않는 실수를 많이 저지른다.
* 연관관계 주인이 아닌 객체는 insert나 update를 할 수 없고 읽기만 할 수 있다.
* mappedBy가 있는 객체는 JPA가 insert, update를 할 때 아예 읽지를 않는다.
* 따라서 값을 입력, 수정하는 것은 연관관계의 주인에서만 가능하다.

* 양방향 연관관계에서는 양쪽에 다 값을 입력해야 한다.
* 순수한 객체 관계를 고려하면 항상 양쪽에 다 값을 입력해야 한다.
* 양쪽에 값을 넣어주지 않으면 db에 반영하지 않고 1차 캐시에서 값을 가져올 때는 값이 없다(em.persist()한 상태 그대로 가져오기 때문).
* jpa 없이 테스트 케이스 작성할 때에는 무조건 양쪽에 모두 값을 넣어주어야 한다(순수 객체 상태).

* 연관관계 편의 메서드를 생성하자.
* 연관관계 편의 메서드가 양쪽에 있으면 문제(무한루프)가 될 수 있기 때문에 한 쪽에만 생성해서 사용하자.
* 상황마다 어느 쪽에 정의하는게 편한지 보고 정하면 된다.

* 양방향 매핑시에 무한 루프를 조심하자.
* ex) toString(), lombok, JSON 생성 라이브러리 등
* team.toString(), member.toString()이 계속 왔다갔다 하면서 실행된다.
* lombok의 toString 생성하는 것은 웬만하면 쓰지 않는 것이 좋다.
* JSON 생성 라이브러리 문제는 Entity를 DTO로 변환해서 반환하면 해결된다.
* Entity를 그대로 Controller에 반환하면 Entity 객체를 변경하는 경우에 API 스펙도 바뀌어야 하기 때문에 유지보수가 좋지 않다.
* 그렇기 때문에 Entity는 DTO로 변환해서 반환하는 것을 추천한다.

<양방향 매핑 정리>
* 양방향 매핑은 가급적이면 하면 안된다(단방향 매핑으로 설계 완료해야 함).
* 객체 입장에서 양방향으로 설계해서 좋을 것이 없다(이점은 적은데 비해 신경써야할 것은 엄청 많아짐).
* 양방향 매핑은 실무에서 역방향으로 탐색할 일이 많을 경우에 추가해도 된다(테이블 수정 없이 Entity 객체 조금 수정으로 가능).
* 단방향 매핑을 잘 사용하고 양방향은 필요할 때만 추가하자.
* 양방향 매핑을 사용하는 경우 연관관계 편의 메서드를 사용해서 양쪽 엔티티에 값을 넣어주자.
* 연관관계의 주인을 정하는 기준은 비즈니스 로직이 아니라 외래키이다(외래키가 있는 테이블(다쪽)이 연관관계 주인).
참고 : 복잡한 JPQL을 짤 때 양방향 연관관계가 필요한 경우가 있고 그때 양방향 연관관계를 만들면 된다.
참고 : 관계형 db에서는 다쪽에 외래키가 생성되는 설계가 맞다(항상).

<연관관계 매핑시 고려사항>
1. 다중성
(1) 다대일 : @ManyToOne
* 다대일 단방향 : 가장 많이 사용하는 연관관계이다.
* 다대일 양방향 : 반대쪽에 일대다 연관관계를 주면 된다(테이블에 영향을 안 줌).
	       외래키가 있는 쪽이 연관관계의 주인이고, 양쪽을 서로 참조(연관관계 편의 메서드 등)하도록 개발해야 한다.
(2) 일대다 : @OneToMany
a) 일대다 단방향 : 일이 연관관계 주인인 경우도 가능하다(권장하지는 않음).
* 외래키가 연관관계 주인 테이블이 아닌 반대편 테이블에 있기 때문에 연관관계 주인을 변경하면 반대편 테이블의 외래키가 update되는 경우가 발생한다(헷갈림).
* 객체와 테이블의 차이 때문에 반대편 테이블의 외래키를 관리하는 특이한 구조가 된다.
* 일대다 단방향은 @JoinColumn을 꼭 사용해야 한다. 그렇지 않으면 조인 테이블 방식을 사용한다.
* 조인 테이블 방식은 두 연관된 테이블의 기본키를 가지는 중간 테이블을 생성한다(성능이슈, 테이블이 늘어나 운영 어려움).
* 실무에서는 테이블이 한두 개가 아니기 때문에 일대다 단방향으로 하면 운영할 때 힘들다.
* 일대다 단방향 대신 다대일 단방향으로 하고 역참조가 꼭 필요한 경우에만 양방향으로 바꾸는 방식으로 한다.
b) 일대다 양방향
* 공식적으로는 없지만 야매로 가능하다.
* @JoinColumn(name = "", insertable = false, updateable = false) : 연관관계 주인이지만 mappedBy(읽기전용)를 간접적으로 구현.
* 이렇게 하지말고 그냥 다대일 양방향을 사용하자..
(3) 일대일 : @OneToOne
* 주 테이블 : 액세스를 자주 하는 테이블.
* 대상 테이블 : 주 테이블의 반대 테이블.
* 일대일 관계는 그 반대도 일대일이다.
* 주 테이블이나 대상 테이블 중에 외래키를 선택할 수 있다(두 테이블 모두 외래키 가능).
* 외래키에 unique 제약조건을 추가한다(일대일 관계이기 때문).
a) 주 테이블에 외래키 단방향
* 방법은 다대일 단방향 매핑과 동일하다(어노테이션만 @OneToOne을 사용).
b) 주 테이블에 외래키 양방향
* 마찬가지로 다대일 양방향과 비슷하게 하면 된다(반대편은 mappedBy 적용).
* 다대일 양방향 매핑처럼 외래키가 있는 곳이 연관관계의 주인이다.
* 장점 : 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능(객체지향 개발자가 선호, JPA 매핑 편리).
* 단점 : 값이 없으면 외래키에 null 허용해야함(DBA 입장에서 치명적).
c) 대상 테이블에 외래키 단방향, 양방향
* 대상 테이블에 외래키가 있는 단방향은 JPA가 지원하지 않고 양방향 관계는 지원한다.
* 대상 테이블에 외래키 양방향은 대상 테이블을 주 테이블처럼 사용하는 것이다(말장난 비슷).
* 일대일 관계에서 어느 테이블에 외래키를 주든 상관없다.
* 장점 : 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조를 그대로 유지할 수 있다(DBA 선호).
* 단점 : 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩된다(성능 이슈, 치명적).
* 프록시 객체를 만들려면 외래키 필드에 값이 있는지(프록시 객체) 없는지(null) 알아야 되는데, 대상 테이블에 외래키가 있을 경우 즉시 로딩을 해서 확인해야 한다.
d) 일대다 단방향 연관관계의 딜레마(DBA vs 개발자)
* 미래에 연관관계가 변할 수도 있기 때문에 다가 될 수 있는 테이블에 외래키를 주는 것이 좋을 수 있다(DBA 입장).
* 반면에, 다가 될 가능성이 있는 테이블에 외래키를 주는 것이 성능과 개발 편의성이 나쁘다면 좋지 않을 수도 있다(개발자 입장).
* 김영한 님은 너무 먼 미래를 상정하지 않고 성능, 개발 이점을 챙기는 선택을 많이 한다고 함.
* 일대일 단방향 관계에서 어느 테이블에 외래키를 줄 지는 여러 가능성을 따져보고 논의한 후에 결정해야할 문제이다.
(4) 다대다 : @ManyToMany, 실무에서 쓰면 안됨!
* 관계형 db는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없다.
* 연결 테이블을 추가해서 일대다, 다대일 관계로 다대다 관계를 풀어내야 한다.
* 객체는 컬렉션 2개를 사용해서 다대다 관계를 표현할 수 있다.
* 객체에 다대다 관계(@ManyToMany)를 설정하면 JPA는 db에 연결 테이블을 생성해서 다대다 관계를 매핑해준다.
* @ManyToMany 사용하여 매핑하고, @JoinTable로 연결 테이블을 지정 가능하고, 단방향/양방향 모두 가능하다.
* 편리해보이지만 실무에선 사용하면 절대 안된다.
* 실무에서 연결 테이블은 단순히 연결만 하고 끝나지 않고 주문시량, 수량같은 데이터가 들어올 수 있다.
* JPA의 다대다 관계는 매핑 정보만 들어가고 다른 데이터는 들어갈 수 없다.
* 연결 테이블에 조인을 해야하므로 쿼리도 예측하기 힘든 형식으로 나가게 된다(연결 테이블이 객체에서는 보이지 않으므로).
* 다대다 한계 극복 : @ManyToMany -> @OneToMany, @ManyToOne(연결 테이블용 엔티티를 추가함)
* 전통적인 방법으로는 연결 테이블의 외래키들을 기본키로 사용하는 식별 관계를 사용하기도 하지만 비식별 관계를 사용하는 것을 추천한다.
* 기본키는 웬만하면 아무 의미 없는 값을 사용하는 것이 좋다(중복 방지, 자동 생성, uuid 등).
* 기본키가 다른 속성에 종속적이면 시스템을 유연하게 바꾸기가 쉽지 않다(운영, 유지보수에 불리).

2. 단방향, 양방향
1) 테이블
* 테이블은 외래키 하나로 양쪽 조인이 가능하다(방향이라는 개념이 없음).
2) 객체
* 객체는 참조용 필드가 있는 쪽으로만 참조가 가능하다(방향성).
* 한쪽만 참조하면 단방향, 양쪽이 서로 참조하면 양방향(단방향 2개)이다.

3. 연관관계의 주인
* 객체의 양방향 관계는 참조가 2군데 있기 때문에 둘 중 테이블의 외래키를 관리할 곳을 지정해야 한다.
* 연관관계의 주인 : 외래키를 관리하는 참조.
* 주인의 반대편 : 외래키에 영향을 주지 않고 단순 조회만 가능.





















































