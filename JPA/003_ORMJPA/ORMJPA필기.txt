엔티티 매니저는 쓰레드 간에 공유하면 절대 안된다.
JPA의 모든 데이터 변경은 트랜잭션 내에서 실행해야 한다(수정, 삭제, 삽입).

JPQL : SQL을 추상화한 객체 지향 쿼리 언어.
엔티티 객체를 대상으로 쿼리를 작성한다.
db 방언에 맞춰서 JPA가 번역을 해준다.
SQL 문법과 유사하다(select, from, where, group by, having, join 지원).

<영속성 컨텍스트 상태 종류>
1) 비영속 상태 : JPA와는 상관없는 상태(엔티티 객체 생성)
2) 영속 상태 : 영속성 컨텍스트(1차 캐시)가 객체를 관리하는 상태(em.persist())
3) 준영속 상태 : 영속성 컨텍스트에서 분리된 상태(em.detach())
4) 삭제 : 객체를 삭제한 상태(em.remove())
* 트랜잭션이 커밋될 때 db에 쿼리를 날린다.

<영속성 컨텍스트의 이점>
1) 1차 캐시(영속성 컨텍스트)
2) 동일성(identity) 보장( == )
3) 트랜잭션을 지원하는 쓰기 지연(transactional write-behind)
4) 변경 감지(Dirty Checking)
5) 지연 로딩(Lazy Loading)

<1차 캐시>
* 1차 캐시의 key 값은 @Id 어노테이션을 붙인 멤버변수이고, value 값은 엔티티 객체가 된다.
* 조회할 때 먼저 1차 캐시에 있는지 확인하고 있으면 1차 캐시값으로 반환하고, 없으면 DB에서 조회한 후 1차 캐시에 저장하고 반환해준다.
* 1차 캐시는 트랜잭션 단위에서만 존재하기 때문에 그렇게 큰 성능의 이점이 있지는 않다.

<영속 엔티티의 동일성 보장>
* 같은 트랜잭션 내에서 똑같은 식별자를 갖는 인스턴스에 대해 같은 주소를 참조한다.
* 1차 캐시로 반복 가능한 읽기(Repeatable Read) 등급의 트랜잭션 격리 수준을 db가 아닌 애플리케이션 차원에서 제공한다.

<트랜잭션을 지원하는 쓰기 지연>
* 커밋하는 순간 한꺼번에 DB에 insert 쿼리를 보낸다.
* em.persist(memberA)를 하면 memberA가 1차 캐시에 들어가고, JPA가 엔티티를 분석해서 insert 쿼리를 쓰기 지연 SQL 저장소에 저장한다.
* 마찬가지로 em.persist(memberB)도 위와 같은 과정이 일어나고 tx.commit()을 하면 쓰기 지연 SQL 저장소의 SQL이 DB로 보내진다(em.flush()).
* 버퍼링 가능(모았다가 한 번에 db로 보냄, 성능 향상 여지가 있음)

<엔티티 수정 - 변경 감지>
* 트랜잭션 commit을 하면 em.flush()가 호출된다.
* 1차 캐시에는 스냅샷과 엔티티가 저장되는데, 스냅샷에는 값을 읽어온 시점의 데이터가 저장되어 있고, 엔티티는 최종적으로 변경된 엔티티의 데이터가 들어있다.
* flush() 함수는 스냅샷과 엔티티를 비교하여 달라진 부분의 update 쿼리들을 생성하여 쓰기 지연 SQL 저장소에 저장한다.
* 그 다음 update 쿼리를 db에 반영하고 commit을 한다.
* 참고: em.remove() 함수도 비슷하게 동작하지만 update 쿼리가 delete 쿼리로 바뀐다는 점만 다르다.

<플러시(flush)>
* 영속성 컨텍스트의 변경 내용을 db에 반영하는 것(영속성 컨텍스트와 db를 동기화).
* 플러시를 해도 1차 캐시는 모두 유지가 되고, 쓰기 지연 SQL 저장소에 있는 SQL만 db에 반영한다.
* 커밋 직전에만 동기화하면 된다(트랜잭션이라는 작업단위가 중요!).
* 사용법
1) em.flush() : 직접 호출.
2) 트랜잭션 커밋 전 : 플러시 자동 호출.
3) JPQL 쿼리 실행 전 : 플러시 자동 호출.
* 플러시 모드 옵션(쓸 일은 잘 없음) : em.setFlushMode(FlushModeType.COMMIT)
1) FlushModeType.AUTO : 커밋이나 쿼리를 실행할 때 플러시(기본값)
2) FlushModeType.COMMIT : 커밋할 때만 플러시

<준영속 상태>
* 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached)된 상태.
* 영속성 컨텍스트가 제공하는 기능을 사용할 수 없다(변경 감지, 지연 로딩 등).
* 준영속 상태 만드는 방법
1) em.detach(entity) : 특정 엔티티만 준영속 상태로 전환.
2) em.clear() : 영속성 컨텍스트를 완전히 초기화.
3) em.close() : 영속성 컨텍스트를 종료.

<db 스키마 자동 생성>
* ddl을 애플리케이션 실행 시점에 자동 생성.
* db 방언을 활용해서 db에 적절한 ddl을 생성.
* 생성된 ddl은 꼭 개발 단계에서만 사용해야 함.
* 생성된 ddl은 운영서버에서는 사용하지 않거나 적절히 다듬은 후 사용해야 함.
* hibername.hbm2ddl.auto(maven)을 persistence.xml 파일에 등록해서 사용.
* 옵션
1) create : 기존 테이블 삭제 후 다시 생성(drop + create)
2) create-drop : create와 같으나 종료시점에 테이블 drop(drop + create + drop, 테스트 케이스인 경우)
3) update : 변경분만 반영(운영 db에서는 사용하면 안됨, 컬럼 삭제는 안됨)
4) validate : 엔티티와 테이블이 정상 매핑되었는지만 확인.
5) none : 사용하지 않음.
* 주의점
1) 운영 장비에는 절대 create, create-drop, update를 사용하면 안된다!
2) 개발 초기 단계는 create 또는 update
3) 테스트 서버는 update 또는 validate
4) 스테이징과 운영 서버는 validate 또는 none
5) 개발 서버나 테스트 서버에서도 가급적이면 create, create-drop, update는 사용을 지양하자(JPA가 생성하는 sql은 위험할 수 있음).

<ddl 생성 기능>
* 런타임에 영향을 주지 않는 ddl을 자동으로 생성해주는 기능.
* ddl 생성 기능은 ddl을 자동 생성할 때만 사용되고 JPA의 로직에는 영향을 주지 않는다.
* ex) 제약조건 추가(unique, not null, length 등)

<객체와 테이블 매핑>
1. @Entity
* JPA가 관리 하는 클래스 위에 붙인다.
* JPA를 사용해서 테이블과 매핑할 클래스에 필수.
* 주의!
1) 기본 생성자 필수(파라미터가 없는 public 또는 protected 생성자)
2) final 클래스, enum, interface, inner 클래스에는 사용 못함
3) 저장할 필드에 final 사용하면 안됨
* 속성
1) name : JPA에서 사용할 엔티티 이름을 지정한다(기본값 : 클래스 이름, 같은 이름을 클래스가 없으면 기본값을 사용하자).

2. @Table
* 속성
1) name : 엔티티와 매핑할 테이블을 지정한다.
2) uniqueConstraints : unique 제약조건(이름, 컬럼 등)을 직접 작성할 수 있다.

<필드와 컬럼 매핑>
1. @Column
* 속성
1) name : 필드와 매핑할 db 컬럼명을 지정.
2) insertable, updateable : 등록, 변경 가능 여부 지정(기본값은 true).
3) nullable : null 값의 허용 여부 지정(false는 not null, true(기본값)은 null).
4) unique : 유니크 제약 조건 여부 지정(true는 unique, false는 unique X). 이름이 랜덤하게 생성돼서 잘 안 쓰임.
5) columnDefinition : db 컬럼 정보를 직접 줄 수 있다. ex) varchar(100) default 'EMPTY'
6) length : 문자 길이 제약조건, String 타입에만 사용한다.
7) precision, scale
* BigDecimal이나 BigInteger 타입에 사용한다.
* precision은 소수점을 포함한 전체 자릿수를 지정한다.
* scale은 소수의 자릿수를 지정한다.
* 참고로 double, float 타입에는 적용되지 않는다(정밀한 소수를 다루어야할 때만 사용).

2. @Enumerated(EnumType.STRING)
* Enum 타입을 사용할 컬럼 위에 선언한다.
* Enum 타입은 STRING이나 ORDINAL(기본값)이 있는데 STRING을 사용하는 게 에러를 줄일 수 있다.

3. @Temporal(TemporalType.TIMESTAMP)
* 날짜 타입을 쓸 컬럼 위에 선언한다.
* LocalDate, LocalDateTime을 사용하면 생략할 수 있다.
* Temporal 타입
1) DATE : 날짜
2) TIME : 시간
3) TIMESTAMP : 날짜 + 시간

4. @Lob
* varchar 타입을 넘어서는 크기가 큰 컨텐츠(blob, clob)를 넣을 경우 사용한다.
* 속성을 지정할 게 없다.
* 매핑할 타입이 문자이면 clob(String, char[], java.sql.CLOB), 나머지는 blob(byte[], java.sql.BLOB)으로 매핑된다.

5. @Transient
* 테이블에 매핑을 하지 않고 메모리에서만 사용할 멤버변수 위에 선언한다.

<기본키 매핑>
1. @Id : 직접 할당
2. @GeneratedValue : 자동 할당
* 속성
1) strategy : 기본키 자동 생성 전략을 선택한다.
GenerationType.IDENTITY : 기본키 생성을 데이터베이스에 위임(MySql의 Auto_Increment).
GenerationType.SEQUENCE : 시쿼스 오브젝트를 통해 값을 가져오고 세팅해줌(Oracle에서 주로 사용됨, @SequenceGenerator로 설정할 수 있음).
GenerationType.TABLE : 키 생성 전용 테이블을 하나 만들어서 db 시퀀스를 흉내내는 전략(모든 db에 적용 가능, 성능이 낮음, @TableGenerator로 설정할 수 있음). 
* 권장하는 식별자 전략
자연키 : 주민등록번호, 전화번호 등
대리키(대체키) : 자동 생성 키, 랜덤 값 등
기본키는 null이면 안되고, 유일하고, 변하면 안된다.
이 조건을 만족하는 자연키는 찾기 어렵기 때문에 대리키를 사용하는 것을 권장한다.
ex) Long형 + 대체키 + 키 생성 전략 사용
* IDENTITY 전략
1) db에 값을 넣어봐야 기본키 값을 알 수 있기 때문에 이 전략만 예외적으로 em.persist()하면 insert 쿼리를 db에 날린다.
2) 그리고나서 jpa가 내부적으로 insert한 데이터를 가져온다(영속 상태).
3) 그렇기 때문에 IDENTITY 전략에서는 데이터를 모아서 한 번에 insert하는 것이 불가능하다(버퍼링해서 insert 하는 게 큰 메리트는 아님, 작은 단점).
참고 : 트랜잭션을 여러 번 잘라서 하는 건 성능에 문제가 될 수 있지만 한 트랜잭션 안에서 여러 번 쿼리를 날리는 것은 크게 문제가 되진 않는다.
* SEQUENCE 전략
1) em.persist()하면 시퀀스에서 pk값을 가져오고 tx.commit()할 때 insert 쿼리를 날린다(영속 상태로 만들기 위해서는 pk값이 필요하기 때문).
2) @SequenceGenerator 속성 중 initialValue, allocationSize를 사용하면 db에 allocationSize만큼 시퀀스를 미리 생성해놓고 생성된 시퀀스를 다 쓰기 전까지는 메모리에서 시퀀스를 사용(db 시퀀스 쿼리x)하게 된다.
* TABLE 전략
테이블 전략도 SEQUENCE 전략과 마찬가지로 @TableGenerator 속성 중 initialValue, allocationSize를 사용하여 최적화할 수 있다(동시성 문제 없음).

<연관관계 기초>
객체를 테이블에 맞추어 데이터 중심으로 모델링하면 협력관계를 만들 수 없다.
* 테이블은 외래키로 조인해서 연관된 테이블을 찾는다.
* 객체는 참조를 사용해서 연관된 객체를 찾는다.
* 테이블과 객체 사이의 이런 큰 간극이 있다.

<단방향 연관관계>
* 연관관계를 매핑할 때는 현재 클래스의 기준에서 @ManyToOne, @ManyToMany, @OneToOne, @OneToMany를 사용한다.
* @JoinColumn(name = "[조인할 테이블 컬럼]") : 어떤 컬럼으로 조인할 것인지 지정한다.

<양방향 연관관계>
참고 : 관례로 컬렉션 멤버 변수는 초기화를 함(NullPointException 방지).
* 양방향 연관관계 : 연관관계인 Entity 양쪽에 모두 레퍼런스를 넣어두고 서로 참조를 할 수 있는 관계.
* 테이블의 연관관계는 외래키 하나로 양방향 연관관계가 가능하다(방향의 개념 자체가 없음).
* 객체의 연관관계는 객체의 레퍼런스가 있어야지 참조할 수 있다(방향성이 있음).
* 양방향 연관관계는 가급적이면 사용하지 않는 것이 좋다(신경써야할 것들이 많아짐).
ex) @OneToMany(mappedBy = "team") : 반대편 Entity의 멤버변수 team과 연결되어 있다는 의미.
* mappedBy를 왜 사용하는지 근본적인 이유를 알지 못하면 언제 사용해야 하는지 감이 오지 않는다.
* 객체와 테이블이 관계를 맺는 차이를 이해하면 mappedBy를 사용하는 이유에 대해 알 수 있다.
1) 객체의 연관관계(단방향 2개)
회원 -> 팀 연관관계(단방향)
팀 -> 회원 연관관계(단방향)
2) 테이블의 연관관계(양방향 1개)
회원 <-> 팀의 연관관계(양방향, 엄밀히 말하면 방향이 없음(외래키 하나만 있으면 됨))
* 객체의 양방향 관계는 사실 양방향 관계가 아니라 서로 다른 단방향 관계 2개이다(단방향 연관관계 2개를 만들어야 함).
* 테이블은 외래키 하나로 두 테이블의 연관관계를 관리한다(양쪽으로 조인할 수 있음).
* JPA가 테이블을 매핑할 때 양방향 연관관계는 외래키를 어떤 것으로 매핑해야 할지 헷갈리게 된다.
* 그렇기 때문에 양방향 연관관계에서는 둘 중 하나로 외래키를 관리해야 한다(연관관계 주인).

<연관관계의 주인>
* 진짜 매핑 : 연관관계의 주인, 가짜 매핑 : 주인의 반대편(mappedBy)
* 양방향 연관관계에서 객체의 두 관계 중 하나를 연관관계의 주인으로 지정한다.
* 연관관계의 주인만이 외래키를 관리(등록, 수정)한다.
* 주인이 아닌 쪽은 읽기만 가능하다!!
* 주인은 mappedBy 속성을 사용하지 않고, 주인이 아닌 객체에 mappedBy 속성으로 주인을 지정해준다.
* 테이블 입장에서 보면 무조건 외래키가 있는 곳이 다이고, 외래키가 없는 곳이 일이다.
* 연관관계의 주인은 외래키가 있는 곳으로 하면 된다(다대일 관계라면 다쪽).
* 만약 외래키가 없는 곳으로 연관관계 주인을 지정하면 sql이 외래키가 있는 테이블로 나가기 때문에 헷갈릴 수 있다(직관적이지 않음).
* 외래키가 없는 연관관계 주인은 성능 이슈도 있다(나중에 자세히, 쿼리가 여러 번 나갈 수 있음).
* 연관관계의 주인은 비즈니스적으로 중요한 객체가 아니라 연관관계에서 다쪽이다.
* 그렇게 해야 설계도 깔끔하고 성능 이슈도 없다.

<양방향 매핑시 주의점>
* 양방향 연관관계 매핑시 연관관계의 주인에 값을 입력하지 않는 실수를 많이 저지른다.
* 연관관계 주인이 아닌 객체는 insert나 update를 할 수 없고 읽기만 할 수 있다.
* mappedBy가 있는 객체는 JPA가 insert, update를 할 때 아예 읽지를 않는다.
* 따라서 값을 입력, 수정하는 것은 연관관계의 주인에서만 가능하다.

* 양방향 연관관계에서는 양쪽에 다 값을 입력해야 한다.
* 순수한 객체 관계를 고려하면 항상 양쪽에 다 값을 입력해야 한다.
* 양쪽에 값을 넣어주지 않으면 db에 반영하지 않고 1차 캐시에서 값을 가져올 때는 값이 없다(em.persist()한 상태 그대로 가져오기 때문).
* jpa 없이 테스트 케이스 작성할 때에는 무조건 양쪽에 모두 값을 넣어주어야 한다(순수 객체 상태).

* 연관관계 편의 메서드를 생성하자.
* 연관관계 편의 메서드가 양쪽에 있으면 문제(무한루프)가 될 수 있기 때문에 한 쪽에만 생성해서 사용하자.
* 상황마다 어느 쪽에 정의하는게 편한지 보고 정하면 된다.

* 양방향 매핑시에 무한 루프를 조심하자.
* ex) toString(), lombok, JSON 생성 라이브러리 등
* team.toString(), member.toString()이 계속 왔다갔다 하면서 실행된다.
* lombok의 toString 생성하는 것은 웬만하면 쓰지 않는 것이 좋다.
* JSON 생성 라이브러리 문제는 Entity를 DTO로 변환해서 반환하면 해결된다.
* Entity를 그대로 Controller에 반환하면 Entity 객체를 변경하는 경우에 API 스펙도 바뀌어야 하기 때문에 유지보수가 좋지 않다.
* 그렇기 때문에 Entity는 DTO로 변환해서 반환하는 것을 추천한다.

<양방향 매핑 정리>
* 양방향 매핑은 가급적이면 하면 안된다(단방향 매핑으로 설계 완료해야 함).
* 객체 입장에서 양방향으로 설계해서 좋을 것이 없다(이점은 적은데 비해 신경써야할 것은 엄청 많아짐).
* 양방향 매핑은 실무에서 역방향으로 탐색할 일이 많을 경우에 추가해도 된다(테이블 수정 없이 Entity 객체 조금 수정으로 가능).
* 단방향 매핑을 잘 사용하고 양방향은 필요할 때만 추가하자.
* 양방향 매핑을 사용하는 경우 연관관계 편의 메서드를 사용해서 양쪽 엔티티에 값을 넣어주자.
* 연관관계의 주인을 정하는 기준은 비즈니스 로직이 아니라 외래키이다(외래키가 있는 테이블(다쪽)이 연관관계 주인).
참고 : 복잡한 JPQL을 짤 때 양방향 연관관계가 필요한 경우가 있고 그때 양방향 연관관계를 만들면 된다.
참고 : 관계형 db에서는 다쪽에 외래키가 생성되는 설계가 맞다(항상).

<연관관계 매핑시 고려사항>
1. 다중성
(1) 다대일 : @ManyToOne
* 다대일 단방향 : 가장 많이 사용하는 연관관계이다.
* 다대일 양방향 : 반대쪽에 일대다 연관관계를 주면 된다(테이블에 영향을 안 줌).
	       외래키가 있는 쪽이 연관관계의 주인이고, 양쪽을 서로 참조(연관관계 편의 메서드 등)하도록 개발해야 한다.
(2) 일대다 : @OneToMany
a) 일대다 단방향 : 일이 연관관계 주인인 경우도 가능하다(권장하지는 않음).
* 외래키가 연관관계 주인 테이블이 아닌 반대편 테이블에 있기 때문에 연관관계 주인을 변경하면 반대편 테이블의 외래키가 update되는 경우가 발생한다(헷갈림).
* 객체와 테이블의 차이 때문에 반대편 테이블의 외래키를 관리하는 특이한 구조가 된다.
* 일대다 단방향은 @JoinColumn을 꼭 사용해야 한다. 그렇지 않으면 조인 테이블 방식을 사용한다.
* 조인 테이블 방식은 두 연관된 테이블의 기본키를 가지는 중간 테이블을 생성한다(성능이슈, 테이블이 늘어나 운영 어려움).
* 실무에서는 테이블이 한두 개가 아니기 때문에 일대다 단방향으로 하면 운영할 때 힘들다.
* 일대다 단방향 대신 다대일 단방향으로 하고 역참조가 꼭 필요한 경우에만 양방향으로 바꾸는 방식으로 한다.
b) 일대다 양방향
* 공식적으로는 없지만 야매로 가능하다.
* @JoinColumn(name = "", insertable = false, updateable = false) : 연관관계 주인이지만 mappedBy(읽기전용)를 간접적으로 구현.
* 이렇게 하지말고 그냥 다대일 양방향을 사용하자..
(3) 일대일 : @OneToOne
* 주 테이블 : 액세스를 자주 하는 테이블.
* 대상 테이블 : 주 테이블의 반대 테이블.
* 일대일 관계는 그 반대도 일대일이다.
* 주 테이블이나 대상 테이블 중에 외래키를 선택할 수 있다(두 테이블 모두 외래키 가능).
* 외래키에 unique 제약조건을 추가한다(일대일 관계이기 때문).
a) 주 테이블에 외래키 단방향
* 방법은 다대일 단방향 매핑과 동일하다(어노테이션만 @OneToOne을 사용).
b) 주 테이블에 외래키 양방향
* 마찬가지로 다대일 양방향과 비슷하게 하면 된다(반대편은 mappedBy 적용).
* 다대일 양방향 매핑처럼 외래키가 있는 곳이 연관관계의 주인이다.
* 장점 : 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능(객체지향 개발자가 선호, JPA 매핑 편리).
* 단점 : 값이 없으면 외래키에 null 허용해야함(DBA 입장에서 치명적).
c) 대상 테이블에 외래키 단방향, 양방향
* 대상 테이블에 외래키가 있는 단방향은 JPA가 지원하지 않고 양방향 관계는 지원한다.
* 대상 테이블에 외래키 양방향은 대상 테이블을 주 테이블처럼 사용하는 것이다(말장난 비슷).
* 일대일 관계에서 어느 테이블에 외래키를 주든 상관없다.
* 장점 : 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조를 그대로 유지할 수 있다(DBA 선호).
* 단점 : 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩된다(성능 이슈, 치명적).
* 프록시 객체를 만들려면 외래키 필드에 값이 있는지(프록시 객체) 없는지(null) 알아야 되는데, 대상 테이블에 외래키가 있을 경우 즉시 로딩을 해서 확인해야 한다.
d) 일대다 단방향 연관관계의 딜레마(DBA vs 개발자)
* 미래에 연관관계가 변할 수도 있기 때문에 다가 될 수 있는 테이블에 외래키를 주는 것이 좋을 수 있다(DBA 입장).
* 반면에, 다가 될 가능성이 있는 테이블에 외래키를 주는 것이 성능과 개발 편의성이 나쁘다면 좋지 않을 수도 있다(개발자 입장).
* 김영한 님은 너무 먼 미래를 상정하지 않고 성능, 개발 이점을 챙기는 선택을 많이 한다고 함.
* 일대일 단방향 관계에서 어느 테이블에 외래키를 줄 지는 여러 가능성을 따져보고 논의한 후에 결정해야할 문제이다.
(4) 다대다 : @ManyToMany, 실무에서 쓰면 안됨!
* 관계형 db는 정규화된 테이블 2개로 다대다 관계를 표현할 수 없다.
* 연결 테이블을 추가해서 일대다, 다대일 관계로 다대다 관계를 풀어내야 한다.
* 객체는 컬렉션 2개를 사용해서 다대다 관계를 표현할 수 있다.
* 객체에 다대다 관계(@ManyToMany)를 설정하면 JPA는 db에 연결 테이블을 생성해서 다대다 관계를 매핑해준다.
* @ManyToMany 사용하여 매핑하고, @JoinTable로 연결 테이블을 지정 가능하고, 단방향/양방향 모두 가능하다.
* 편리해보이지만 실무에선 사용하면 절대 안된다.
* 실무에서 연결 테이블은 단순히 연결만 하고 끝나지 않고 주문시량, 수량같은 데이터가 들어올 수 있다.
* JPA의 다대다 관계는 매핑 정보만 들어가고 다른 데이터는 들어갈 수 없다.
* 연결 테이블에 조인을 해야하므로 쿼리도 예측하기 힘든 형식으로 나가게 된다(연결 테이블이 객체에서는 보이지 않으므로).
* 다대다 한계 극복 : @ManyToMany -> @OneToMany, @ManyToOne(연결 테이블용 엔티티를 추가함)
* 전통적인 방법으로는 연결 테이블의 외래키들을 기본키로 사용하는 식별 관계를 사용하기도 하지만 비식별 관계를 사용하는 것을 추천한다.
* 기본키는 웬만하면 아무 의미 없는 값을 사용하는 것이 좋다(중복 방지, 자동 생성, uuid 등).
* 기본키가 다른 속성에 종속적이면 시스템을 유연하게 바꾸기가 쉽지 않다(운영, 유지보수에 불리).

2. 단방향, 양방향
1) 테이블
* 테이블은 외래키 하나로 양쪽 조인이 가능하다(방향이라는 개념이 없음).
2) 객체
* 객체는 참조용 필드가 있는 쪽으로만 참조가 가능하다(방향성).
* 한쪽만 참조하면 단방향, 양쪽이 서로 참조하면 양방향(단방향 2개)이다.

3. 연관관계의 주인
* 객체의 양방향 관계는 참조가 2군데 있기 때문에 둘 중 테이블의 외래키를 관리할 곳을 지정해야 한다.
* 연관관계의 주인 : 외래키를 관리하는 참조.
* 주인의 반대편 : 외래키에 영향을 주지 않고 단순 조회만 가능.

<상속관계 매핑>
* 관계형 db는 상속관계가 없다.
* 관계형 db에서 슈퍼타입 서브타입 관계라는 모델링 기법이 객체의 상속과 유사하다.
* 상속관계 매핑 : 객체의 상속과 구조와 db의 슈퍼타입 서브타입 관계를 매핑하는 것.
* JOINED, SINGLE_TABLE, TABLE_PER_CLASS 전략이 있다.
* JOINED와 SINGLE_TABLE 사이에서 trade-off를 따져보고 선택해야한다(TABLE_PER_CLASS는 사용 안함).
* 상속관계가 단순하고 확장 가능성 낮은 경우에는 SINGLE_TABLE, 복잡한 경우에는 JOINED를 주로 사용한다.
<상속관계 매핑 어노테이션>
1. 부모 클래스 위에 @Inheritance(strategy = InheritanceType.XXX). 기본값은 SINGLE_TABLE.
(1) 조인 전략(InheritanceType.JOINED)
* 각각 테이블로 변환
* 장점
1) 테이블 정규화.
2) 외래키 참조 무결성 제약조건 활용가능.
3) 저장공간 효율화.
* 단점
1) 조회시 조인을 많이 사용, 성능 저하.
2) 조회 쿼리가 복잡합.
3) 데이터 저장시 insert sql 2번 호출.

(2) 단일 테이블 전략(InheritanceType.SINGLE_TABLE)
* 통합 테이블로 변환
* 장점
1) 조인이 필요 없으므로 일반적으로 조회 성능이 빠름.
2) 조회 쿼리가 단순함.
* 단점
1) 자식 엔티티가 매핑한 컬럼은 모두 null 허용(치명적).
2) 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있다. 상황에 따라서 조회 성능이 오히려 낮아질 수 있다.

(3) 구현 클래스마다 테이블 전략(InheritanceType.TABLE_PER_CLASS)
* 서브타입 테이블로 변환
* 주의! db 설계자와 ORM 전문가 둘 다 추천하지 않는 전략(사용하면 안되는 전략).
* 장점
1) 서브 타입을 명확하게 구분해서 처리할 떄 효과적.
2) not null 제약조건 사용 가능
* 단점
1) 여러 자식 테이블을 함께 조회할 때 성능이 느림(union sql).
2) 자식 테이블을 통합해서 쿼리하기 어려움.

2. 부모 클래스 위에 @DiscriminatorColumn : DTYPE(default) 컬럼을 부모 테이블에 추가해준다.
* name 속성으로 컬럼명을 변경할 수 있음.
* JOINED 전략일 때는 필요한 경우 작성해어야 DTYPE 컬럼이 생성된다.
* SINGLE_TABLE 전략에서는 생략해도 DTYPE 컬럼이 생성된다(싱글 테이블의 경우에는 DTYPE 컬럼이 꼭 필요함).
* TABLE_PER_CLASS 전략에서는 부모 테이블이 생성되지 않으므로 사용하는 의미가 없다.
* 참고 : DTYPE 컬럼은 어떤 전략을 사용하더라도 꼭 있는 게 운영할 때 편하다(부모 테이블만 조회해도 어떤 자식 테이블에 속하는지 확인 가능).

3. 자식 클래스 위에 @DiscriminatorValue : DTYPE 컬럼에 들어갈 값을 지정할 수 있다(default는 Entity명).
* 속성명 없이 변경하고 싶은 값을 주면 된다.

<@MappedSuperClass>
* 상속관계 매핑과는 다르다.
* 엔티티가 아니기 때문에 테이블과 매핑되지 않는다.
* 부모 클래스를 상속 받는 자식 클래스에 매핑 정보만 제공한다.
* 조회, 검색 불가(em.find(BaseEntity)) 불가.
* 직접 생성해서 사용할 일이 없으므로 추상 클래스를 권장한다.
* 테이블과 관계 없고, 단순히 엔티티가 공통으로 사용하는 매핑 정보를 모으는 역할을 한다.
* 주로 등록일, 수정일, 등록자, 수정자 같은 전체 엔티티에서 공통으로 적용하는 정보를 모을 때 사용한다.
* 참고 : @Entity 클래스는 엔티티 혹은 @MappedSuperclass로 지정한 클래스만 상속받을 수 있다.

<프록시와 연관관계 관리>
1. 프록시
* em.find() : db를 통해서 실제 엔티티 객체를 조회한다(db 쿼리 날림).
* em.getReference() : db 조회를 미루는 가짜(프록시) 엔티티 객체를 조회한다(db 쿼리 안 날림).
(1) 프록시 객체의 초기화
: memberProxy.getName() -> 영속성 컨텍스트에 초기화 요청 -> db 조회 -> 실제 entity 생성 -> target(member).getName()

(2) 프록시 특징
* 실제 클래스를 상속 받아서 만들어지고, 실제 클래스와 겉 모양이 같다.
* 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 된다(이론상).
* 프록시 객체는 실제 객체의 참조(target)를 보관한다.
* 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드를 호출한다.
* 프록시 객체는 처음 사용할 때 한 번만 초기화된다.
* 프록시 객체를 초기화할 때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아니다(초기화되면 프록시 객체를 통해서 실제 엔티티에 접근 가능).
** 프록시 객체는 원본 엔티티를 상속받는다. 따라서 타입 체크시 주의해야 한다(== 비교는 실패, 대신 instanceof 사용해야 함).
** 객체의 타입을 비교할 때는 프록시 객체가 올지 엔티티 객체가 올지 모르기 때문에 꼭 instanceof를 사용해야 한다!(ex. m1 instanceof Member)
*** 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티를 반환한다.
*** jpa는 한 트랜잭션 내에서 같은 식별자를 갖는 인스턴스에 대해 == 연산의 결과를 true로 보장해준다.
*** ex) id가 1L인 멤버, getReference() ==> 프록시 객체, find() ==> 프록시 객체로 조회한다.
**** 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시 초기화 문제가 발생한다(org.hibernate.LazyInitializationException 예외).

(3) 프록시 확인
* 프록시 인스턴스의 초기화 여부 확인 : emf.getPersistanceUnitUtil.isLoaded(Object entity);
* 프록시 클래스 확인 방법 : entity.getClass().getName();
* 프록시 강제 초기화 : org.hibernate.Hibernate.initialize(entity);
* 참고! JPA 표준은 강제 초기화가 없다.
* 강제 호출 : member.getName();

<즉시로딩과 지연로딩>
1. 즉시로딩(FetchType.EAGER)
* db에서 연관된 엔티티를 한 번에 다 가져온다(Proxy 객체 사용하지 않음).

2. 지연로딩(FetchType.LAZY)
* db에서 해당하는 엔티티만 가져오고, 연관된 엔티티 필드에는 프록시 객체를 넣어둔다.

3. 프록시와 즉시로딩 주의
* 가급적 지연 로딩만 사용하자(특히 실무에서).
* 즉시 로딩을 적용하면 예상하지 못한 SQL이 발생할 수 있다.
* 즉시 로딩은 JPQL에서 N + 1문제를 일으킨다.
* @ManyToOne, @OneToOne은 기본이 즉시로딩이다(FetchType.LAZY로 설정해야 함).
* @OneToMany, @ManyToMany는 기본이 지연로딩이다.

4. N + 1 문제 해결방법(모든 연관관계가 지연로딩이라고 할 때)
(1) fetch 조인
JPQL에서 필요한 엔티티를 동적으로 선택하여 db 쿼리를 날리는 기능이다.
(2) 엔티티 그래프(어노테이션)
(3) 배치 사이즈

5. 지연로딩 활용
* 모든 연관관계에 지연로딩을 사용해라!
* JPQL의 fetch 조인이나, 엔티티 그래프 기능을 사용해라!
* 실무에서 즉시로딩은 상상하지 못한 쿼리가 나가고 N + 1 문제로 인해 성능이 좋지 않을 가능성이 있으므로 사용하지 마라.

<영속성 전이>
1. 영속성 전이 : CASCADE
* 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶을 때 사용한다.
* ex) 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장.

2. 영속성 전이 주의!
* 영속성 전이는 연관관계를 매핑하는 것과 아무 관련이 없다.
* 엔티티를 영속화할 때 연관된 엔티티도 함께 영속화하는 편리함을 제공할 뿐이다.
* 하나의 부모만이 자식들을 관리할 때는 쓰는 것이 의미가 있다(소유자가 하나일 때, 라이프사이클이 거의 같을 때).
ex) 게시판 - 첨부파일 관계
* 다른 엔티티에서도 자식들을 관리할 때는 쓰면 안된다(소유자가 여럿일 때).
ex) 첨부파일을 관리자, 게시판 엔티티가 관리할 때

3. CASCADE의 종류
1) ALL : 모두 적용
2) PERSIST : 영속
3) REMOVE : 삭제
* 4, 5, 6은 잘 안 쓰임.
4) MERGE : 병합
5) REFRESH : REFRESH
6) DETACH : DETACH

<고아 객체>
1. 고아 객체
* 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능이다.
* 고아 객체 제거 : 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 것.
* orphanRemoval = true

2. 고아 객체 주의
* 영속성 전이와 마찬가지로 참조하는 곳이 하나일 때 사용해야 한다!
* 특정 엔티티가 개인 소유할 때 사용해야 한다!
* @OneToOne, @OneToMany만 사용 가능하다.
* 참고 : 개념적으로 부모를 제거하면 자식은 고아가 된다. 따라서 고아 객체 제거 기능을 활성화하면, 부모를 제거할 떄 자식도 함께 제거된다.
	이것은 CascadeType.REMOVE처럼 동작한다.

3. 영속성 전이 + 고아 객체, 생명주기
* CascadeType.ALL + orphanRemoval = true
* 스스로 생명주기를 관리하는 엔티티(부모 엔티티)는 em.persist()로 영속화, em.remove()로 제거한다.
* 두 옵션을 모두 활성화하면 부모 엔티티를 통해서 자식 생명주기를 관리할 수 있다.
* 도메인 주도 설계(DDD)의 Aggregate Root 개념을 구현할 때 유용하다.

<기본값 타입>
1. JPA의 데이터 타입 분류
(1) 엔티티 타입
* @Entity로 정의하는 객체
* 데이터가 변해도 식별자로 지속해서 "추적 가능"하다.
* ex) 회원 엔티티의 키나 나이 값을 변경해도 식별자로 인식 가능.

(2) 값 타입
* int, Integer, String처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체.
* 식별자가 없고 값만 있으므로 변경시 추적이 불가능하다.
* ex) 숫자 100을 200으로 변경하면 완전히 다른 값으로 대체됨.

2. 값 타입 분류
(1) 기본값 타입
* 자바 기본 타입(int, double 등)
* 래퍼 클래스(Integer, Long 등)
* String
(2) 임베디드 타입(embedded type, 복합 값 타입)
(3) 컬렉션 값 타입(collection value type)

3. 기본값 타입
* ex) String name,  int age 등
* 생명주기를 엔티티에 의존한다.
* ex) 회원을 삭제하면 이름, 나이 필드도 함께 삭제됨.
* 값 타입은 공유하면 안된다.
* ex) 회원 일므 변경시 다른 회원의 이름도 함께 변경되면 안됨.

* 참고 : 자바의 기본 타입은 절대 공유되지 않는다.
* int, double 같은 기본 타입(primitive type)은 절대 공유되지 않는다.
* 기본 타입은 항상 값을 복사한다.
* Integer같은 래퍼 클래스나 String 같은 특수한 클래스는 공유 가능한 객체이지만 값을 변경할 수 있는 방법이 없다(사이드 이펙트 발생 가능성이 없음).

<임베디드 타입>
1. 임베디드 타입 설명
* 새로운 값 타입을 직접 정의할 수 있다.
* 주로 기본 값 타입을 모아서 만들고 복합 값 타입이라고도 한다.
* 임베디드 타입은 엔티티가 아니라 int, String과 같은 값 타입이다(추적 불가능).

2. 임베디드 타입 사용법
* @Embeddable : 값 타입을 정의하는 곳에 표시한다.
* @Embedded : 값 타입을 사용하는 곳에 표시한다.
* @Embeddable 클래스에는 기본 생성자가 꼭 있어야 한다.

3. 임베디드 타입의 장점
* 재사용성이 높다.
* 높은 응집도를 가진다.
* Period.isWork()처럼 해당 값 타입만 사용하는 의미있는 메서드를 만들 수 있다.
* 임베디드 타입을 포함한 모든 값 타입은 값 타입을 소유한 엔티티에 생명주기를 의존한다.

4. 임베디드 타입과 테이블 매핑
* 임베디드 타입은 엔티티의 값이다.
* 임베디드 타입을 사용하기 전과 후에 매핑하는 테이블은 같다.
* 객체와 테이블을 아주 세밀하게(find-grained) 매핑하는 것이 가능하다.
* 잘 설계한 ORM 애플리케이션은 매핑한 테이블 수보다 클래스의 수가 더 많다(임베디드 타입 사용).

5. 임베디드 타입과 연관관계
* 임베디드 타입은 엔티티를 필드로 가질 수도 있다.

6. @AttributeOverride: 속성 재정의
* 한 엔티티에서 같은 값 타입을 사용하면 컬럼명이 중복되기 때문에
* @AttributeOverrides와 @AttributeOverride를 사용하여 컬럼명을 재정의한다.

7. 임베디드 타입과 null
* 임베디드 타입의 값이 null이면 매핑한 컬럼 값은 모두 null이다.

<값 타입과 불변 객체>
* 값 타입은 복잡한 객체 세상을 조금이라도 단순화하기 위해 만든 개념이다.
* 그렇기 때문에 값 타입은 단순하고 안전하게 다룰 수 있어야 한다.

1. 값 타입 공유 참조
* 임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 위험하다.
* 부작용(side effect) 발생(값이 변경되면 공유하는 다른 곳의 값도 변경되는 것).
* 값 타입은 부작용이 발생하면 안된다(부작용을 사용하려면 값 타입(임베디드)이 아니라 엔티티로 사용해야 함).

2. 값 타입 복사
* 값 타입의 실제 인스턴스인 값을 공유하는 것은 위험하다.
* 그 대신 값(인스턴스를) 복사해서 사용하자.

3. 객체 타입의 한계
* 항상 값을 복사해서 사용하면 공유 참조로 인해 발생하는 부작용을 피할 수 있다.
* 문제는 임베디드 타입처럼 직접 정의한 값 타입은 자바의 기본 타입이 아니라 객체 타입이므로 참조 값을 직접 대입하는 것(공유 참조)을 막을 방법이 없다.

4. 불변 객체
* 객체 타입을 수정할 수 없게 만들면 부작용의 원천을 차단할 수 있다.
* 값 타입은 불변 객체(immutable object)로 설계해야 한다.
* 불변 객체 : 생성 시점 이후 절대 값을 변경할 수 없는 객체.
* 생성자로만 값을 설정하고 수정자(setter)를 만들지 않으면 불변 객체를 만들 수 있다.
* 참고 : Integer, String은 자바가 제공하는 대표적인 불변 객체이다.
*** 불변이라는 작은 제약으로 부작용이라는 큰 재앙을 막을 수 있다.
* 불변 객체의 값을 바꾸고 싶을 때는 새로운 인스턴스를 생성하면 된다.
* 값이 자주 변경되면 copy 메서드를 따로 만들어서 사용해도 좋다.

<값 타입의 비교>
* 값타입은 인스턴스가 달라도 그 안에 값이 같으면 같은 것으로 봐야 한다.
* 동일성(identity) 비교 : 인스턴스의 참조 값을 비교한다(== 사용).
* 동등성(equivalence) 비교 : 인스턴스의 값을 비교한다(equals() 사용).
* 값 타입은 a.equals(b)를 사용해서 동등성 비교를 해야 한다.
* 값 타입은 equals() 메서드를 적절하게 재정의해서 사용한다(주로 모든 필드 사용).
# 참고
* equals는 자동으로 생성되는 것을 그대로 사용하는 것이 좋다.
* 프록시를 복잡하게 사용하는 경우 equals 메서드 내에서 필드에 직접 접근하는 것이 아니라 getter를 사용해야 할 수도 있다.
* equals 메서드를 재정의할 때는 꼭 hashCode 메서드도 같이 재정의해주어야 한다.

<값 타입 컬렉션>
1. 값 타입 컬렉션 설명
* 값 타입을 하나 이상 저장할 때 사용한다.
* @ElementCollection, @CollectionTable 어노테이션을 사용하여 지정한다.
* db는 컬렉션을 같은 테이블에 저장할 수 없기 때문에 컬렉션을 저장하기 위한 별도의 테이블이 필요하다.
* 값 타입 컬렉션도 지연 로딩 전략을 사용한다(default).
* 참고 : 값 타입 컬렉션은 영속성 전이(Cascade) + 고아 객체 제거 기능을 (따로 지정하지 않아도)필수로 가진다고 볼 수 있다.

2. 값 타입 컬렉션의 제약사항
* 값 타입은 엔티티와 다르게 식별자 개념이 없다.
* 값은 변경하면 추적이 어렵다.
*** 값 타입 컬렉션에 변경 사항이 발생하면 주인 엔티티와 연관된 모든 데이터를 삭제하고, 값 타입 컬렉션에 있는 현재 값을 모두 다시 저장한다.
* 값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본키를 구성해야 함(null 입력 불가, 중복 저장 불가).

*** 값 타입 컬렉션은 실무에서 사용하면 안된다(진짜 단순할 때만 사용, 값이 바뀌어도 update할 필요가 없을 때(추적할 필요 없음)).

3. 값 타입 컬렉션 대안
* 실무에서는 환경에 따라 값 타입 컬렉션 대신에 일대다 관계를 고려해야 한다.
* 일대다 관계를 위한 엔티티를 만들고, 여기에서 값 타입을 사용(래퍼 클래스)한다.
* 영속성 전이(Cascade) + 고아 객체 제거를 사용해서 값 타입 컬렉션처럼 사용한다.

<타입 정리>
1. 엔티티 타입의 특징
* 식별자가 있다.
* 생명주기가 관리된다.
* 공유할 수 있다.

2. 값 타입의 특징
* 식별자가 없다.
* 생명주기를 엔티티에 의존한다.
* 공유하지 않는 것이 안전하다(복사해서 사용).
* 불변 객체로 만드는 것이 안전하다.

3. 값 타입 주의사항
* 값 타입은 정말 값 타입이라고 판단될 때만 사용하자.
* 엔티티와 값 타입을 혼동해서 엔티티를 값 타입으로 만들면 안된다.
* 식별자가 필요하고, 지속해서 값을 추적/변경해야 한다면 그것은 값 타입이 아닌 엔티티로 설계해야 한다.



<jpashop db 테이블 삭제>
drop table album;
drop table book;
drop table movie;
drop table category_item;
drop table category;
drop table orderitem;
drop table orders;
drop table delivery;
drop table item;
drop table member;

<test db 테이블 삭제>
drop table album;
drop table book;
drop table movie;
drop table item;
drop table memberproduct;
drop table member;
drop table team;
drop table product;
drop table locker;
drop table child;
drop table parent;